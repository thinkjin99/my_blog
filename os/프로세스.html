<!DOCTYPE html> <html><head>
		<title>프로세스</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="my_study - 프로세스">
		<meta property="og:title" content="프로세스">
		<meta property="og:description" content="my_study - 프로세스">
		<meta property="og:type" content="website">
		<meta property="og:url" content="os/프로세스.html">
		<meta property="og:image" content="https://velog.velcdn.com/images/curiosity806/post/a3957723-584b-4d34-bc82-c39db63ec07e/image.png">
		<meta property="og:site_name" content="my_study">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript><link rel="preload" href="lib/styles/snippets.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/snippets.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon code-styler code-styler-style-inline code-styler-gutter-highlight"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-mspace{display:inline-block;text-align:left}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-c.mjx-c37::before{padding:.676em .5em .022em 0;content:"7"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}mjx-c.mjx-c36::before{padding:.666em .5em .022em 0;content:"6"}mjx-c.mjx-c1D463.TEX-I::before{padding:.443em .485em .011em 0;content:"v"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c1D44E.TEX-I::before{padding:.441em .529em .01em 0;content:"a"}mjx-c.mjx-c1D454.TEX-I::before{padding:.442em .477em .205em 0;content:"g"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c35::before{padding:.666em .5em .022em 0;content:"5"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-msub{display:inline-block;text-align:left}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D434.TEX-I::before{padding:.716em .75em 0 0;content:"A"}mjx-c.mjx-c1D449.TEX-I::before{padding:.683em .769em .022em 0;content:"V"}mjx-c.mjx-c1D445.TEX-I::before{padding:.683em .759em .021em 0;content:"R"}mjx-c.mjx-c1D443.TEX-I::before{padding:.683em .751em 0 0;content:"P"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block;text-align:left}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mi{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c1D45E.TEX-I::before{padding:.442em .46em .194em 0;content:"q"}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c1D451.TEX-I::before{padding:.694em .52em .01em 0;content:"d"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="프로세스"><p dir="auto">프로세스</p></h1><div class="heading-wrapper"><h3 data-heading="출처" dir="auto" class="heading" id="출처"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>출처</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><a rel="noopener" class="external-link" href="https://dnr2144.tistory.com/42" target="_blank">https://dnr2144.tistory.com/42</a> (리눅스 PCB)</li>
<li data-line="1" dir="auto"><a data-tooltip-position="top" aria-label="https://velog.io/@curiosity806/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%9E%80(%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4" rel="noopener" class="external-link" href="https://velog.io/@curiosity806/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%9E%80(%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4" target="_blank">https://velog.io/@curiosity806/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%9E%80(프로세스</a> 상태)</li>
<li data-line="2" dir="auto"><a rel="noopener" class="external-link" href="https://jhnyang.tistory.com/7" target="_blank">https://jhnyang.tistory.com/7</a> (ready vs waiting)</li>
<li data-line="3" dir="auto"><a rel="noopener" class="external-link" href="https://stackoverflow.com/questions/2483041/what-is-the-difference-between-fork-and-thread" target="_blank">https://stackoverflow.com/questions/2483041/what-is-the-difference-between-fork-and-thread</a> (fork, exec)</li>
<li data-line="4" dir="auto"><a rel="noopener" class="external-link" href="https://stackoverflow.com/questions/5090731/why-fork-and-exec-are-kept-2-seperate-calls" target="_blank">https://stackoverflow.com/questions/5090731/why-fork-and-exec-are-kept-2-seperate-calls</a> (ork와 exec을 구분 이유)</li>
<li data-line="5" dir="auto"><a rel="noopener" class="external-link" href="https://www.tcpschool.com/c/c_memory_stackframe" target="_blank">https://www.tcpschool.com/c/c_memory_stackframe</a> (프로세스 메모리)</li>
<li data-line="6" dir="auto"><a data-tooltip-position="top" aria-label="https://stackoverflow.com/questions/15976333/stack-overflow-caused-by-recursive-function(%EC%9E%AC%EA%B7%80" rel="noopener" class="external-link" href="https://stackoverflow.com/questions/15976333/stack-overflow-caused-by-recursive-function(%EC%9E%AC%EA%B7%80" target="_blank">https://stackoverflow.com/questions/15976333/stack-overflow-caused-by-recursive-function(재귀</a> 스텍 오버플로)</li>
<li data-line="7" dir="auto"><a rel="noopener" class="external-link" href="https://codetravel.tistory.com/31" target="_blank">https://codetravel.tistory.com/31</a> (orphan and zombie)</li>
</ul></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="개요" dir="auto" class="heading" id="개요"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>개요</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><a data-href="#Program, Process" href="#Program,_Process" class="internal-link" target="_self" rel="noopener">Program, Process</a></li>
<li data-line="1" dir="auto"><a data-href="#Process State" href="#Process_State" class="internal-link" target="_self" rel="noopener">Process State</a></li>
<li data-line="2" dir="auto"><a data-href="#PCB" href="#PCB" class="internal-link" target="_self" rel="noopener">PCB</a></li>
<li data-line="3" dir="auto"><a data-href="#PCB in Linux" href="#PCB_in_Linux" class="internal-link" target="_self" rel="noopener">PCB in Linux</a></li>
<li data-line="4" dir="auto"><a data-href="#fork &amp; exec" href="#fork_&amp;_exec" class="internal-link" target="_self" rel="noopener">fork &amp; exec</a></li>
<li data-line="5" dir="auto"><a data-href="#Copy On Write" href="#Copy_On_Write" class="internal-link" target="_self" rel="noopener">Copy On Write</a></li>
<li data-line="6" dir="auto"><a data-href="#fork and exec in shell" href="#fork_and_exec_in_shell" class="internal-link" target="_self" rel="noopener">fork and exec in shell</a></li>
<li data-line="7" dir="auto"><a data-href="#wait &amp; exit" href="#wait_&amp;_exit" class="internal-link" target="_self" rel="noopener">wait &amp; exit</a></li>
<li data-line="8" dir="auto"><a data-href="#Orphan &amp; Zombie" href="#Orphan_&amp;_Zombie" class="internal-link" target="_self" rel="noopener">Orphan &amp; Zombie</a></li>
<li data-line="9" dir="auto"><a data-href="#Process Memory" href="#Process_Memory" class="internal-link" target="_self" rel="noopener">Process Memory</a></li>
</ul></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="Program, Process" dir="auto" class="heading" id="Program,_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Program, Process</h3><div class="heading-children"><div><p dir="auto">프로그램이란 코드로 짜여진 다양한 함수들의 집합으로 <strong>소스코드를 컴파일한 결과가 곧 프로그램</strong>이 된다. 예를 들어 <em>.c 파일을 컴파일하면 a.out이나 </em>.exe 등의 파일이 생성되고 이것이 곧 프로그램이 된다.</p></div><div><p dir="auto"><strong>프로그램은 디스크에 정적으로 위치해 있으며 그 자체만으로는 생명성이 없다</strong>. <u><b>하지만 프로그램이 실행돼 메모리에 올라오면 생명을 띄는데 이러한 생명을 가진 실행중인 프로그램을 프로세스라고 한다. </b></u></p></div><div><p dir="auto">생명을 갖는다는 의미는 말 그대로 상태가 변하거나 죽을 수 있다는 의미로 프로세스는 상태를 가지며 이 상태는 프로세스의 실행 흐름에 따라 변화한다. </p></div><div><p dir="auto">프로세스는 하나 이상의 쓰레드를 가지며 프로세스별로 독립적인 메모리 공간을 할당 받는다. </p></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="Process State" dir="auto" class="heading" id="Process_State"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Process State</h3><div class="heading-children"><div><p dir="auto"><img src="https://velog.velcdn.com/images/curiosity806/post/a3957723-584b-4d34-bc82-c39db63ec07e/image.png" referrerpolicy="no-referrer"><br>
프로세스는 위와 같은 상태들을 가지며 이러한 상태의 변경은 전부 커널에서 이뤄진다. PCB에 대한 접근은 커널 영역에서만 가능하기 때문이다. 이러한 상태들은 스케줄러 등에서 활용되며 스케줄러는 상태를 확인하고 스케줄링을 진행한다. 뿐만 아니라 자원 회수 등의 작업을 진행할 때도 상태를 기반으로 진행해야 한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>Ready VS Waiting</strong><br>
<strong>Ready는 프로세스를 실행할 자원이 전부 할당 돼 있으며, 스케줄링을 통해 CPU 권한만 받으면 실행할 준비가 돼있는 상태이다. 반대로 Waiting의 경우 프로세스를 당장 실행할 수 없으며 특정한 IO 작업이나 이벤트가 발생해야 프로세스를 실행할 자원이 모두 준비되는 상태를 말한다.</strong></p>
<p dir="auto">따라서 Run -&gt; Ready로 갈 경우 프로세스가 곧장 다시 스케줄링될 수도 있으나 Run -&gt; Waiting으로 갈 경우 이벤트 완료를 통한 인터럽트를 발생하지 않으면 영영 스케줄링되지 않을 수 있다. </p>
<p dir="auto">Run -&gt; Waiting의 대표적인 사례는 유저 입력으로 유저 입력이 완료될 때까지 해당 프로세스는 블락돼 있을 수 있다. Run -&gt; Ready의 사례로는 시스템 콜이 있으며 시스템 콜 실행으로 인해 해당 프로세스가 잠시 블락된 것이지 시스템콜의 종료와 함께 곧장 재 실행할 수 있다.<br>
<a data-href="스케줄러#Process Scheduling Condition" href="os/스케줄러.html#Process_Scheduling_Condition" class="internal-link" target="_self" rel="noopener">스케줄러 &gt; Process Scheduling Condition</a></p>
</li>
</ul></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="PCB" dir="auto" class="heading" id="PCB"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>PCB</h3><div class="heading-children"><div><p dir="auto"><span class="red red-bg">PCB는 OS에서 프로세스를 추상화해 관리하기 위해 사용하는 자료구조이다. PCB에는 프로세스에 관한 모든 정보가 저장되며 OS는 이를 통해 프로세스를 관리한다.</span> PCB는 아무 프로세스에서나 접근 가능하면 안되기에 커널의 데이터 영역에 저장된다.</p></div><div><p dir="auto"><img src="https://velog.velcdn.com/images/curiosity806/post/06d141f2-ff5a-4855-a064-b90f218bc0e2/image.png" referrerpolicy="no-referrer"></p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><b><span class="green green-bg">PCB는 왜 필요할까?</span></b><br>
프로세스가 CPU에서 실행될 때는 CPU의 레지스터 내부에 프로세스의 정보가 저장돼 있기 때문에 프로세스의 정보를 별도로 저장할 필요가 없다. 하지만 <b><span class="red-bg red">컨텍스트 스위칭에의해 레지스터에 저장된 데이터가 교체되면 현재 프로세스의 정보를 별도의 형태로 저장할 필요가 발생</span></b>하게 되고 이를 위해 PCB가 만들어졌다.</li>
</ul></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><b>PCB는 컨텍스트 스위칭 때문에 존재한다. 스위칭이 없는 멍청한 OS라면 PCB가 필요 없다.</b></p>
</div></div></div><div><p dir="auto"><img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20Pasted%20image%2020231012231241.png" referrerpolicy="no-referrer"></p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>PROCESS ID</strong>: 프로세스와 그 자식 프로세스 식별을 위해 사용하는 ID</li>
</ul></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>STATE</strong>: 프로세스의 상태를 저장하는 속성</li>
<li data-line="1" dir="auto"><strong>PROGRAM COUNTER</strong>: CPU가 다음으로 실행할 기계어를 가리키는 값을 의마한다. 메모리에 적재된 다음 명령어(기계어)의 메모리 위치를 뜻한다.</li>
<li data-line="2" dir="auto"><strong>REGISTER INFO</strong>: CPU의 범용 레지스터, 연산 레지스터 등에 있던 값을 의미한다. </li>
<li data-line="3" dir="auto"><strong>SCHEDULING INFO</strong>: 우선순위, 실행시간, CPU 점유시간 등을 저장한다. </li>
<li data-line="4" dir="auto"><strong>OPEN FILE LIST</strong>: 프로세스에서 사용하고 있는 파일 리스트를 저장한다.</li>
<li data-line="5" dir="auto"><strong>MEMORY INFO</strong>: 프로세스 내부에서 사용하는 메모리의 위치, 용량, 페이지 테이블 등의 정보를 갖는다.</li>
<li data-line="6" dir="auto"><strong>PCB POINTER</strong>: 현재 프로세스의 자원들을 저장한 메모리 위치를 가리키는 포인터를 말한다. 부모/자식 프로세스의 PCB, 메모리, 레지스터에 대한 포인터 등을 말한다.</li>
</ul></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><strong>PCB에는 다음과 같은 정보들이 저장되며 이를 통해 프로세스의 상태를 기록한다.</strong></p>
</div></div></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="PCB in Linux" dir="auto" class="heading" id="PCB_in_Linux"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>PCB in Linux</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>PCB를 직접 확인해보려면 어떻게 해야할까?</strong><br>
<u><b>리눅스 커널에서는 PCB를 task_struct로 구현해 관리한다. 해당 구조체는 커널 영역에 존재하며 유저 영역에서 이를 접근하려면 proc 파일 시스템을 통해 제공해주는 간접적인 정보를 통해 확인할 수 있다.</b></u> 아래는 /proc 폴더 아래에 특정한 프로세스의 status 파일의 상태이다. /proc은 실시간으로 값이 변화하며 유저는 이를 통해 현재 프로세스의 상태를 파악할 수 있다.<br>
<img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-13%20%EC%98%A4%EC%A0%84%2011.44.37.png" referrerpolicy="no-referrer"></li>
</ul></div><div><p dir="auto">직접적으로 task_struct에 접근하고 싶으면 커널을 뜯으면 된다. 해당 구조체는 <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L738" target="_blank" rel="noopener">sched.h</a>에 저장돼 있다. task_struct의 세부 구조는 다음과 같다.</p></div><div><p dir="auto"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUf3qn%2FbtqVdMS5sIN%2F1PKsZV0qVx2CxWgjCAV8h1%2Fimg.png" referrerpolicy="no-referrer"><br>
크게 6개의 구조체(basic task struct + 5)로 PCB를 구성한다는 것을 확인할 수 있는데 이는 각각 메모리, 터미널 정보, 사용 중인 파일, 파일 시스템 정보 등이다. 물론 이외에도 쓰레드, 자식 프로세스, 레지스터 등 수많은 속성들이 모여 task_sturct를 만든다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>왜 PCB는 구조체의 집합의 형태로 만들어졌을까?</strong><br>
자식 프로세스 생성을 유리하게 하기 위함이다. 자식 프로세스를 생성할 때 모든 속성을 복사해줄 필요가 있을까? 자식 프로세스가 사용하는 터미널이나, 파일들이 전부 부모 프로세스와 동일할 수 있다.<br>
<strong>따라서 자식 프로세스를 생성할 때 필요한 부분만 별개로 복사하고 싶은 욕구가 발생하게 되고 이에 따라 PCB를 여러개의 속성으로 분리해 관리 가능하게 설계</strong>했다. </li>
</ul></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="fork &amp; exec" dir="auto" class="heading" id="fork_&amp;_exec"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>fork &amp; exec</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="fork" dir="auto" class="heading" id="fork"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>fork</h4><div class="heading-children"><div><p dir="auto"><strong>fork를 할 경우 부모 프로세스의 PCB를 그대로 자식 프로세스에 복사</strong> 해준다. <strong>복사를 하는 것이기 때문에 부모와 자식의 메모리는 개별적으로 존재하고 오버헤드가 큰 편</strong>이다. fork는 pid를 반환하며 pid가 0일 경우 자식 프로세스가 실행중이라는 의미가 된다.</p></div><div><p dir="auto">fork를 할 경우 자식 프로세스는 레디큐로 편입 되며 스케줄링 될 경우 부모 프로세스가 fork()를 한 시점부터 실행한다. <u><b>이는 fork를 할 경우 pc, 버퍼, 페이지 테이블 값들까지 메모리 영역을 전부 복사하기 때문이다</b></u> (여기서 몇몇 <a href="ttps://stackoverflow.com/questions/2530663/printf-anomaly-after-fork" target="_blank" rel="noopener">문제</a>가 발생하기도 한다). 엄밀히 따지면 복사는 아니다. 실제 복사를 곧장 하는 영역은 스택 영역 뿐이고 나머지 영역은 <a data-href="#Copy On Write" href="#Copy_On_Write" class="internal-link" target="_self" rel="noopener">Copy On Write</a>로 관리된다.</p></div><div><p dir="auto"><span class="red red-bg">fork()를 할 경우 pid는 다르지만 기존의 프로세스와 동일한 프로세스가 복제돼 생성된다. 이는 fork()가 clone() 시스템 콜을 응용해 만들어졌기 때문이다. </span></p></div><div><pre dir="auto" class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token string">""</span><span class="token string">"num 값은 복사되기 때문에 프로세스 별로 개별존재하고 공유되지 않는다 "</span><span class="token string">""</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm Running %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        num <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child id %d end\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        num <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent %d \n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent id %d end\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span class="red red-bg">fork() 함수는 부모 프로세스와 자식 프로세스 각각에 총 2번 반환을 진행한다. 자식 프로세스에는 0을 반환하고 부모 프로세스에는 생성한 자식 프로세스의 pid 번호를 반환 해준다.</span></p></div></div></div><div class="heading-wrapper"><h4 data-heading="exec" dir="auto" class="heading" id="exec"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>exec</h4><div class="heading-children"><div><p dir="auto"><strong>exec은 현재 프로세스를 다른 프로세스로 뒤집어 씌우는 기능을 수행한다. exec을 실행한 이후로 기존 프로세스의 값들은 전부 신규 실행되는 프로세스의 값으로 대체 된다.</strong><br>
exec을 실행한 이후에는 전혀 다른 프로세스가 되므로 이후의 코드 값은 실행되지 않는다.</p></div><div><pre dir="auto" class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> </span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execute is\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-al"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//별도의 프로세스가 된다.</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"code still alive..?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl is failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><hr dir="auto"></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Copy On Write" dir="auto" class="heading" id="Copy_On_Write"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Copy On Write</h3><div class="heading-children"><div><p dir="auto">앞서 배운 fork에는 프로세스의 내용을 전부 복사하려다 보니 오버헤드가 크다는 단점이 존재한다. 이에 따라 <a data-href="#PCB" href="#PCB" class="internal-link" target="_self" rel="noopener">PCB</a>에서 설명했듯이 부분적으로만 복사하는 방법 + 참신한 방법을 사용하는데 이를 통해 빠른 fork가 가능해진다. </p></div><div><p dir="auto"><span class="red red-bg">Copy On Write의 핵심 아이디어는 데이터의 수정이 발생했을 때 복사를 진행하는 것이다. 만약 부모나 자식 프로세스에서 데이터에 수정을 가한다면 그때 복사를 진행하고 개별적으로 분리된 데이터에 수정을 진행한다.</span> 만약 수정이 없다면 자식은 부모의 메모리 영역을 read-only로 접근해 사용한다.</p></div><div><p dir="auto"><img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-05%20%EC%98%A4%ED%9B%84%208.58.05.png" referrerpolicy="no-referrer"></p></div><div><blockquote dir="auto">
<p dir="auto">[!info]<br>
<strong>수정이 발생했을 때 발생한 일부분을 복사해주는 것이 COW의 핵심 원리이다.</strong></p>
</blockquote></div><div><p dir="auto"><strong>힙 영역과 데이터 영역이 COW에의해 관리되고 스텍 영역의 경우 fork 실행과 동시에 복사된다. 코드 영역의 경우 공유해 사용한다.</strong></p></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="fork and exec in shell" dir="auto" class="heading" id="fork_and_exec_in_shell"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>fork and exec in shell</h3><div class="heading-children"><div><pre dir="auto" class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> pid<span class="token operator">=</span><span class="token number">7</span>  <span class="token operator">|</span>
<span class="token operator">|</span> ppid<span class="token operator">=</span><span class="token number">4</span> <span class="token operator">|</span>
<span class="token operator">|</span> bash   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
    <span class="token operator">|</span>
    <span class="token operator">|</span> calls fork
    V
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>             <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> pid<span class="token operator">=</span><span class="token number">7</span>  <span class="token operator">|</span>    forks    <span class="token operator">|</span> pid<span class="token operator">=</span><span class="token number">22</span> <span class="token operator">|</span>
<span class="token operator">|</span> ppid<span class="token operator">=</span><span class="token number">4</span> <span class="token operator">|</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token operator">|</span> ppid<span class="token operator">=</span><span class="token number">7</span> <span class="token operator">|</span>
<span class="token operator">|</span> bash   <span class="token operator">|</span>             <span class="token operator">|</span> bash   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>             <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
    <span class="token operator">|</span>                      <span class="token operator">|</span>
    <span class="token operator">|</span> waits <span class="token keyword">for</span> pid <span class="token number">22</span>     <span class="token operator">|</span> calls exec to run ls
    <span class="token operator">|</span>                      V
    <span class="token operator">|</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
    <span class="token operator">|</span>                  <span class="token operator">|</span> pid<span class="token operator">=</span><span class="token number">22</span> <span class="token operator">|</span>
    <span class="token operator">|</span>                  <span class="token operator">|</span> ppid<span class="token operator">=</span><span class="token number">7</span> <span class="token operator">|</span>
    <span class="token operator">|</span>                  <span class="token operator">|</span> ls     <span class="token operator">|</span>
    V                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>                 <span class="token operator">|</span>
<span class="token operator">|</span> pid<span class="token operator">=</span><span class="token number">7</span>  <span class="token operator">|</span>                 <span class="token operator">|</span> exits
<span class="token operator">|</span> ppid<span class="token operator">=</span><span class="token number">4</span> <span class="token operator">|</span> <span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> bash   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
    <span class="token operator">|</span>
    <span class="token operator">|</span> continues
    V
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">쉘에서는 신규 명령어를 실행할 경우 다음과 같은 순서로 실행된다. fork와 exec을 별개의 작업으로 분리해 실행하는데, 곧장 명령어를 곧장 실행하지 않고 굳이 fork후 exec을 해주는 이유가 뭘까?</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>쉘에서 fork를 사용해 명령어를 처리하는 이유</strong><br>
<u>쉘에서 직접 실행하지 않고 fork를 활용해 명령어를 처리하는 이유는 메모리 격리와 다중 작업 등을 위함이다.</u> 만약 쉘 프로세스 내부에서 명령어들도 처리해야 한다면, 해당 명령어를 처리하다 오류가 생길 경우 명령어 뿐 아니라 쉘에게 까지 영향이 갈 확률이 존재한다. 또한 명령어와 쉘이 같은 메모리 공간을 공유함에 따라 문제가 발생할 가능성도 존재한다.</p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><strong>쉘에서 fork and exec으로 명령어를 처리하는 이유</strong><br>
fork 후에 exec을 실행하면 새로운 "프로세스 생성 → 특정 프로세스 대체" 두 단계로 새로운 프로세스 실행이 완료된다. spawn이라는 명령어를 만들어서 한번에 fork, exec을 동시에 실행해 버리면 편하지 않을까 싶지만, 이 경우 <strong>프로세스 생성 이후 프로세스의 파일 디스크립터 같은 속성 변경에 어려움이 발생</strong>한다. <span class="red red-bg">반대로 fork이후 설정을 변경하고 exec을 하면 설정이 변경된 프로세스에서 원하는 프로그램을 수행하는 것이 가능해진다</span></p>
<p dir="auto"><span class="red red-bg">리다이렉션이나 파이프 라인 등이 위의 원리로 구현된다. </span>fork를 통해 프로세스를 생성한 다음 파이프라인이나 리다이렉션이 위치한 파일로 프로세스의 속성을 변경한다. 이후 exec을 통해 프로세스를 대체한 다음 실시한다. </p>
</li>
</ul></div><div><p dir="auto">MIT 강의 자료에 따르면... </p></div><div><blockquote dir="auto">
<p dir="auto">Now it should be clear why it is a good idea that fork and exec are separate calls. <strong>Because if they are separate, the shell can fork a child, use open, close, dup in the child to change the standard input and output file descriptors, and then exec.</strong> No changes to the program being exec-ed (cat in our example) are required. <strong>If fork and exec were combined into a single system call, some other (probably more complex) scheme would be required for the shell to redirect standard input and output, or the program itself would have to understand how to redirect I/O.</strong></p>
</blockquote></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><strong>쉘은 명령어를 fork -&gt; exec의 방식으로 처리하고 이는 메모리 격리와 리다이렉션 등을 제공하기 위해 사용한다.</strong></p>
</div></div></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="wait &amp; exit" dir="auto" class="heading" id="wait_&amp;_exit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>wait &amp; exit</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="wait" dir="auto" class="heading" id="wait"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>wait</h4><div class="heading-children"><div><p dir="auto"><strong>부모 프로세스가 자식 프로세스의 실행을 대기하게 할 때 사용하는 함수</strong>이다. 이는 블락킹 함수로 부모 프로세스는 자식 프로세스의 실행이 완료될 때까지 블락된다. 정수형 포인터를 전달함으로써 프로세스의 상태 값 (정수 리턴 값)을 부모 프로세스로 전달 받을 수 있다. <strong>wait를 적절히 하지 않을 경우 부모 프로세스가 자식 프로세스보다 먼저 종료되는 현상이 발생하는데 이는 <u><i>고아 프로세스나 좀비 프로세스</i></u>와 같은 문제를 발생시킬 수 있으므로 프로세스를 종료할 땐 wait를 되도록 사용해줄 필요가 있다.</strong></p></div><div><pre dir="auto" class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d is start.\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Switch!</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d ended. \n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent %d is start.\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent %d ended. \n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// wait(NULL);</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-17%20%EC%98%A4%ED%9B%84%202.16.01.png" referrerpolicy="no-referrer"></p></div><div><p dir="auto">위의 예제를 실행해보면 부모 프로세스가 먼저 종료된 이후 자식 프로세스가 종료되는 것을 확인할 수 있다. <strong>쉘에서 부모 프로세스가 종료된 후 자식 프로세스가 마저 종료 되므로 출력이 아래와 같이 출력된다.</strong> 위와 같은 예제가 대표적인 고아 프로세스를 생성하는 예시이다. </p></div><div><p dir="auto"><span class="red red-bg">고아 프로세스를 생성하고 싶지 않다면, wait를 사용해 부모 프로세스에서 자식 프로세스의 종료를 기다려야 한다.</span>  wait를 사용할 경우 아래와 같은 결과가 나온다.<br>
<img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-17%20%EC%98%A4%ED%9B%84%202.21.42.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h4 data-heading="exit" dir="auto" class="heading" id="exit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>exit</h4><div class="heading-children"><div><p dir="auto"><strong>프로세스를 종료하는 함수이다. exit을 할 경우 열려있는 파일을 모두 닫고 버퍼에 있던 내용을 모두 출력하고 종료한다. 또한 해당 프로세스에서 할당한 모든 메모리 영역을 반환한다</strong>. exit 내부에는 오류 코드를 입력하게 되는데 0일 경우 정상 종료 1일 경우 비정상 종료를 의미한다. </p></div><div><p dir="auto"><strong>exit은 프로그램이 종료되면 항상 실행</strong>되는데 main 함수가 정상 완료되면 자동으로 exit 시스템 콜을 호출해주고 오류 등으로 인해 프로세스가 강제 종료 되더라도 exit함수는 실행된다.</p></div><div><hr dir="auto"></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Orphan &amp; Zombie" dir="auto" class="heading" id="Orphan_&amp;_Zombie"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Orphan &amp; Zombie</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="Orphan Process" dir="auto" class="heading" id="Orphan_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Orphan Process</h4><div class="heading-children"><div><p dir="auto"><span class="red red-bg">고아 프로세스는 부모 프로세스가 먼저 실행 종료된 프로세스 </span>를 의미한다. 고아 프로세스가 되는 경우 해당 프로세스로 인해 메모리 누수가 발생할 수 있고 프로세스를 모니터링하고 중지 시키는 작업에 차질이 발생한다.</p></div><div><p dir="auto">고아 프로세스가 지속적으로 발생한다면 큰 자원 낭비로 연결되기 때문에 대다수의 OS는 이를 처리하기 위한 별도의 로직을 제공한다. <span class="red red-bg">리눅스의 경우  init process를 사용해 고아 프로세스들을 종료 시킨다. init process는 고아 프로세스를 입양해 적절히 종료 시키는 작업을 수행한다. </span></p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>init process</strong><br>
<u><b>init process는 리눅스 부팅중 가장 먼저 실행되는 프로세스로 프로세스 트리의 루트에 위치한 프로세스이다.</b></u> 리눅스의 모든 프로세스는 해당 프로세스의 자식이다.<br>
init 프로세스는 다양한 작업을 수행하는데 그중 고아 프로세스들을 입양하고 정상적으로 종료하는 기능도 존재한다. 고아원이 존재 하므로 맘 놓고 고아를 만들어도 될 것 같지만, 입양과정에서 제법 큰 오버헤드가 발생하기 때문에 되도록 입양은 발생하지 않게 하는 것이 좋다.</li>
</ul></div><div><pre dir="auto" class="language-c" tabindex="0"><code class="language-c is-loaded">
<span class="token comment">//orphan_test.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token class-name">pid_t</span> childPid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    childPid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>childPid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// Parent 프로세스</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent PID : %d, pid : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">childPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent 종료\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childPid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// Child 코드</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child 시작\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child PID : %d Parent PID : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child 종료\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> <span class="token comment">// fork 실패</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork fail! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">위의 코드를 실행하면 고아 프로세스의 부모 프로세스가 어떻게 변경되고 종료 되는지를 확인할 수 있다. 결과를 보면 부모가 종료되면서 parent가 init 프로세스로 변경돼 실행되는 것을 확인 할 수 있다.</p></div><div><p dir="auto"><img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-17%20%EC%98%A4%ED%9B%84%203.12.03.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h4 data-heading="Zombie Process" dir="auto" class="heading" id="Zombie_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Zombie Process</h4><div class="heading-children"><div><p dir="auto">좀비 프로세스는 부모 프로세스에서 wait()이나 waitpid()로 자식 프로세스의 상태를 명확히 파악하지 않았을 때 발생하는 프로세스이다. <u><b>wait를 하지 않을 경우 리소스는 사용하지 않고 테이블에만 존재하는 좀비 프로세스가 생성된다.</b></u> </p></div><div><p dir="auto">자식 프로세스는 실행이 완료되면 exit()을 호출하며 사용하던 리소스를 전부 반환하지만, 부모 프로세스에서 자식 프로세스의 상태나 PID 등은 확인하고 싶을 수 있기 때문에 이러한 정보들은 삭제하지 않는다. <span class="red red-bg">좀비 프로세스는 실행되지 않으므로 타 프로세스의 성능에 큰 영향을 미치지 않는다. 하지만 메모리에 정보를 저장시키고 PID(PID도 유한하다)를 계속 차지 함으로 낭비를 유발한다.</span></p></div><div><p dir="auto">좀비 프로세스는 이미 죽은 프로세스이기 때문에 일반적인 kill로 죽지 않는다. 좀비 프로세스를 죽이고 싶다면 <code class="code-styler-inline">kill -s SIGCHLD pid</code>과 같은 특별한 시그널을 송신해 메모리에서 지워 줘야 한다.</p></div><div><pre dir="auto" class="language-c" tabindex="0"><code class="language-c is-loaded">
<span class="token comment">//zombie_test.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> childPid<span class="token punctuation">;</span>
    childPid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>childPid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent is running\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//zombie born</span>
        <span class="token comment">//wait(NULL);</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childPid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child is running\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child is End\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">위의 코드를 생성하면 인위적으로 좀비 프로세스가 생성되는 것을 확인 할 수 있다. wait를 입력하고 실행하면 좀비 프로세스가 생성되지 않는다. 좀비는 부모 프로세스가 살아있다면 절대 사라지지 않는다. 부모가 사라질 경우 init 프로세스에 입양되고 삭제 된다.<br>
<img src="https://my-study.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-17%20%EC%98%A4%ED%9B%84%203.50.11.png" referrerpolicy="no-referrer"></p></div><div><hr dir="auto"></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Process Memory" dir="auto" class="heading" id="Process_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Process Memory</h3><div class="heading-children"><div><p dir="auto">프로세스의 주요 메모리는 Code(Text), Data, Bss, Stack, Heap 영역으로 구분할 수 있다. 해당 영역은 프로세스 별로 존재하며 프로세스간 공유를 하기 위해선 별도의 방법이 필요하다.</p></div><div><p dir="auto"><img src="https://wikidocs.net/images/page/165974/2-27.png" referrerpolicy="no-referrer"></p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>코드 영역, 데이터 영역</strong><br>
<strong>코드 영역은 프로그램 실행에 필요한 코드가 올라오는 영역</strong>으로 읽기 전용이다. Data 영역은 전역 변수및 스테틱 변수들을 저장한다. <u><b>두 영역에 할당할 메모리 크기는 컴파일 타임에 결정되며 프로세스 동작 중에 변경되지 않는다.</b></u></p>
</li>
<li data-line="3" dir="auto">
<p dir="auto"><b><span class="red red-bg">스택 영역 </span></b><br>
<strong>스택 영역은 프로세스의 함수 호출과 관련된 정보들이 저장된다.<br>
스택 영역은 함수 호출과 함께 할당되며, 함수 호출이 완료되면 소멸한다. 함수가 호출되면 스택에는 함수의 매개변수, 반환주소, 지역변수 등이 저장된다. 스택 영역은 스택 자료구조 형태로 저장되는데 이에 따라 함수를 순차적으로 실행하고 종료하는 것이 가능하다.</strong></p>
</li>
</ul></div><div><p dir="auto"><img src="https://www.tcpschool.com/lectures/img_c_stackframe_01.png" referrerpolicy="no-referrer"><br>
함수를 종료할 경우 아래와 같이 종료된다 스택에서 pop을 진행하며 가장 늦게 실행된 함수 부터 추출해 종료하는 방식이다.<br>
<img src="https://www.tcpschool.com/lectures/img_c_stackframe_02.png" referrerpolicy="no-referrer"><br>
이러한 구조를 띄고 있기 때문에 함수를 순차적으로 실행하거나 함수 실행중 원래 실행 흐름으로 돌아가 실행하는 것이 가능해진다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto">
<p dir="auto"><strong>재귀함수 스택 오버플로</strong><br>
스택은 제한된 메모리 용량이기 때문에 너무 많은 함수가 호출돼 스택을 가득 매울 경우 오버 플로우가 발생할 수 있다. 이에 따라 각 프로그램은 최대 재귀 깊이 등을 제한해 이와 같은 문제를 방지한다.<br>
<img src="https://www.tcpschool.com/lectures/img_c_stackoverflow.png" referrerpolicy="no-referrer"></p>
</li>
<li data-line="4" dir="auto">
<p dir="auto"><strong>힙 영역 메모리</strong><br>
<strong>힙 영역은 동적으로 할당된 데이터를 저장하는 공간으로 런타임 중 할당이 가능한 공간이다. 힙 메모리는 프로그램의 실행에 따라 크기가 동적으로 변경될 수 있다.</strong></p>
<p dir="auto">힙 영역 메모리 할당은 malloc 등을 통해 가능하며, 명시적으로 할당을 해제 해주지 않을 경우 메모리 낭비가 발생할 수 있다.</p>
</li>
</ul></div><div><hr dir="auto"></div><div class="mod-footer"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="os/프로세스.html#프로세스"><div class="tree-item-contents heading-link" heading-name="프로세스"><span class="tree-item-title">프로세스</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#출처"><div class="tree-item-contents heading-link" heading-name="출처"><span class="tree-item-title">출처</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#개요"><div class="tree-item-contents heading-link" heading-name="개요"><span class="tree-item-title">개요</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#Program,_Process"><div class="tree-item-contents heading-link" heading-name="Program, Process"><span class="tree-item-title">Program, Process</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#Process_State"><div class="tree-item-contents heading-link" heading-name="Process State"><span class="tree-item-title">Process State</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#PCB"><div class="tree-item-contents heading-link" heading-name="PCB"><span class="tree-item-title">PCB</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#PCB_in_Linux"><div class="tree-item-contents heading-link" heading-name="PCB in Linux"><span class="tree-item-title">PCB in Linux</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#fork_&amp;_exec"><div class="tree-item-contents heading-link" heading-name="fork &amp; exec"><span class="tree-item-title">fork &amp; exec</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/프로세스.html#fork"><div class="tree-item-contents heading-link" heading-name="fork"><span class="tree-item-title">fork</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/프로세스.html#exec"><div class="tree-item-contents heading-link" heading-name="exec"><span class="tree-item-title">exec</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#Copy_On_Write"><div class="tree-item-contents heading-link" heading-name="Copy On Write"><span class="tree-item-title">Copy On Write</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#fork_and_exec_in_shell"><div class="tree-item-contents heading-link" heading-name="fork and exec in shell"><span class="tree-item-title">fork and exec in shell</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#wait_&amp;_exit"><div class="tree-item-contents heading-link" heading-name="wait &amp; exit"><span class="tree-item-title">wait &amp; exit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/프로세스.html#wait"><div class="tree-item-contents heading-link" heading-name="wait"><span class="tree-item-title">wait</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/프로세스.html#exit"><div class="tree-item-contents heading-link" heading-name="exit"><span class="tree-item-title">exit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#Orphan_&amp;_Zombie"><div class="tree-item-contents heading-link" heading-name="Orphan &amp; Zombie"><span class="tree-item-title">Orphan &amp; Zombie</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/프로세스.html#Orphan_Process"><div class="tree-item-contents heading-link" heading-name="Orphan Process"><span class="tree-item-title">Orphan Process</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/프로세스.html#Zombie_Process"><div class="tree-item-contents heading-link" heading-name="Zombie Process"><span class="tree-item-title">Zombie Process</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/프로세스.html#Process_Memory"><div class="tree-item-contents heading-link" heading-name="Process Memory"><span class="tree-item-title">Process Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>