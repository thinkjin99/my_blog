<!DOCTYPE html> <html><head>
		<title>Async,Await</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="my_study - Async,Await">
		<meta property="og:title" content="Async,Await">
		<meta property="og:description" content="my_study - Async,Await">
		<meta property="og:type" content="website">
		<meta property="og:url" content="os/async,await.html">
		<meta property="og:image" content="https://my-study.s3.ap-northeast-2.amazonaws.com/Async%2CAwait%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-02-13%20%EC%98%A4%ED%9B%84%202.47.33.png">
		<meta property="og:site_name" content="my_study">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript><link rel="preload" href="lib/styles/snippets.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/snippets.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon code-styler code-styler-style-inline code-styler-gutter-highlight"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-mspace{display:inline-block;text-align:left}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-c.mjx-c37::before{padding:.676em .5em .022em 0;content:"7"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}mjx-c.mjx-c36::before{padding:.666em .5em .022em 0;content:"6"}mjx-c.mjx-c1D463.TEX-I::before{padding:.443em .485em .011em 0;content:"v"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c1D44E.TEX-I::before{padding:.441em .529em .01em 0;content:"a"}mjx-c.mjx-c1D454.TEX-I::before{padding:.442em .477em .205em 0;content:"g"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c35::before{padding:.666em .5em .022em 0;content:"5"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-msub{display:inline-block;text-align:left}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D434.TEX-I::before{padding:.716em .75em 0 0;content:"A"}mjx-c.mjx-c1D449.TEX-I::before{padding:.683em .769em .022em 0;content:"V"}mjx-c.mjx-c1D445.TEX-I::before{padding:.683em .759em .021em 0;content:"R"}mjx-c.mjx-c1D443.TEX-I::before{padding:.683em .751em 0 0;content:"P"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block;text-align:left}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mi{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c1D45E.TEX-I::before{padding:.442em .46em .194em 0;content:"q"}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c1D451.TEX-I::before{padding:.694em .52em .01em 0;content:"d"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Async,Await"><p dir="auto">Async,Await</p></h1><div class="heading-wrapper"><h3 data-heading="출처" dir="auto" class="heading" id="출처"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>출처</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><a rel="noopener" class="external-link" href="https://bentist.tistory.com/89?category=1010744" target="_blank">https://bentist.tistory.com/89?category=1010744</a> (비동기 개요)</li>
<li data-line="1" dir="auto"><a rel="noopener" class="external-link" href="https://it-eldorado.tistory.com/159" target="_blank">https://it-eldorado.tistory.com/159</a> (테스크의 스케줄링 방법)</li>
<li data-line="2" dir="auto"><a rel="noopener" class="external-link" href="https://tech.buzzvil.com/blog/asyncio-no-1-coroutine-and-eventloop/" target="_blank">https://tech.buzzvil.com/blog/asyncio-no-1-coroutine-and-eventloop/</a> (실습 예제)</li>
<li data-line="3" dir="auto"><a rel="noopener" class="external-link" href="https://soooprmx.com/asyncio/" target="_blank">https://soooprmx.com/asyncio/</a> (테스크, 코루틴, 퓨처</li>
<li data-line="4" dir="auto"><a rel="noopener" class="external-link" href="https://stackoverflow.com/questions/49005651/how-does-asyncio-actually-work" target="_blank">https://stackoverflow.com/questions/49005651/how-does-asyncio-actually-work</a> (파이썬의 asyncio)</li>
</ul></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="개요" dir="auto" class="heading" id="개요"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>개요</h3><div class="heading-children"><div><ul dir="auto">
<li data-line="0" dir="auto"><a data-href="#Async / Await" href="#Async_/_Await" class="internal-link" target="_self" rel="noopener">Async / Await</a></li>
<li data-line="1" dir="auto"><a data-href="#Async/Await 의 동작방식" href="#Async/Await_의_동작방식" class="internal-link" target="_self" rel="noopener">Async/Await 의 동작방식</a></li>
<li data-line="2" dir="auto"><a data-href="#Corutine" href="#Corutine" class="internal-link" target="_self" rel="noopener">Corutine</a></li>
<li data-line="3" dir="auto"><a data-href="#파이썬의 이벤트 루프" href="#파이썬의_이벤트_루프" class="internal-link" target="_self" rel="noopener">파이썬의 이벤트 루프</a></li>
<li data-line="4" dir="auto"><a data-href="#Task" href="#Task" class="internal-link" target="_self" rel="noopener">Task</a></li>
<li data-line="5" dir="auto"><a data-href="#Futures" href="#Futures" class="internal-link" target="_self" rel="noopener">Futures</a></li>
<li data-line="6" dir="auto"><a data-href="#Corutine, Future, Task 한눈에 보기" href="#Corutine,_Future,_Task_한눈에_보기" class="internal-link" target="_self" rel="noopener">Corutine, Future, Task 한눈에 보기</a></li>
<li data-line="7" dir="auto"><a data-href="#파이썬 async의 실행 흐름 자세하게" href="#파이썬_async의_실행_흐름_자세하게" class="internal-link" target="_self" rel="noopener">파이썬 async의 실행 흐름 자세하게</a></li>
<li data-line="8" dir="auto"><a data-href="#await 주의점" href="#await_주의점" class="internal-link" target="_self" rel="noopener">await 주의점</a></li>
</ul></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="Async / Await" dir="auto" class="heading" id="Async_/_Await"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Async / Await</h3><div class="heading-children"><div><p dir="auto"><strong>async/await는 비동기 객체를 쉽게 다루기 위해 고안된 방법으로 미래의 특정 시점에 완료되는 작업을 처리할 때 빛을 발한다.</strong> 해당 방법을 활용하면 콜백 지옥에서 탈출해 depth가 훨씬 적은 우아한 코드 작성이 가능해진다. </p></div><div><p dir="auto">async와 await는 각 언어 별로 사용법이 조금씩 상이하며 해당 글에서는 파이썬을 활용해 설명한다. 아래의 예제를 살펴보자.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">def</span> <span class="token function">login</span><span class="token punctuation">(</span>user_id<span class="token punctuation">:</span><span class="token builtin">str</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	db_hash<span class="token punctuation">:</span><span class="token builtin">str</span> <span class="token operator">=</span> get_db_hash<span class="token punctuation">(</span>user_id<span class="token punctuation">)</span> <span class="token comment">#get_db_hash는 비동기, 논 블락킹으로 동작한다.</span>
	<span class="token comment">#db_hash에 함수의 완료 값이 들어감을 보장할 수 없다.</span>
	<span class="token keyword">if</span> db_hash <span class="token operator">==</span> do_hash<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">200</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">401</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">get_db_hash 함수가 비동기-논블락킹으로 동작한다고 하면 db_hash 변수에 함수의 완료 값이 전달 됐는지를 보장하기 위해선 비지 웨이팅 하던가, 시그널 변수, 콜백 등을 별도로 활용해야 한다. </p></div><div><p dir="auto">이 경우 일반적으로 콜백을 활용해 처리했지만 로직이 중첩될 경우 <a data-tooltip-position="top" aria-label="이벤트 루프 > 프로미스 체인" data-href="이벤트 루프#프로미스 체인" href="os/이벤트-루프.html#프로미스_체인" class="internal-link" target="_self" rel="noopener">콜백지옥</a>에 빠질 수 있다는 것을 앞서 학습했다. 지옥 탈출을 위한 번거로운 작업 없이 async/await를 활용하면 간단히 지옥에서 빠져나올 수 있다.</p></div><div><p dir="auto"><strong>async를 사용해 함수를 코루틴으로 만들고 대기가 발생하는 함수 호출부에 await를 선언 해주면 콜백지옥에서 간단히 빠져나올 수 있다</strong></p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">login</span><span class="token punctuation">(</span>user_id<span class="token punctuation">:</span><span class="token builtin">str</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	db_hash<span class="token punctuation">:</span><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token keyword">await</span> get_db_hash<span class="token punctuation">(</span>user_id<span class="token punctuation">)</span> <span class="token comment"># 이제 해당 함수는 db_hash가 완료될때 까지 블락된다.</span>
	<span class="token keyword">if</span> db_hash <span class="token operator">==</span> do_hash<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">200</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">401</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span class="red red-bg"><b>await 키워드를 함수 호출 부 앞에 선언하면 호출한 함수가 완료될 때까지 해당 함수를 블락한다는 의미가 된다.</b></span> await 이하에 존재하는 코드들은 호출한 함수의 완료를 보장받을 수 있고 번잡한 콜백 체인을 활용하지 않아도 된다.</p></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto">await가 하는 일중 하나는 실행 흐름을 블락하는 것이다.</p>
</div></div></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="Async/Await 의 동작방식" dir="auto" class="heading" id="Async/Await_의_동작방식"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Async/Await 의 동작방식</h3><div class="heading-children"><div><p dir="auto"> <strong>await가 함수의 실행 흐름을 블락킹 한다면</strong>  이는 논 블락킹의 성질을 해치고 오버헤드를 증가 시킬 것이라는 의심을 할 수 있다. 만약 그렇다면 동기-블락킹을 활용하는 것이 더욱 직관적인 방식일 것이다. </p></div><div><p dir="auto"> 아래 예제들을 살펴보며 async/await를 활용하는 경우와 동기-블락킹의 차이를 파악하고 동작 방식을 파악해보자.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">def</span> <span class="token function">saync_random_timer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pending_time <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Wait </span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string"> for </span><span class="token interpolation"><span class="token punctuation">{</span>pending_time<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>pending_time<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string"> is finished..."</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>

<span class="token keyword">def</span> <span class="token function">sync_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        saync_random_timer<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">해당 함수는 동기-블락킹 방식으로 설계 됐으므로 1번 실행, 종료-&gt; 2번 실행, 종료 -&gt; 3, 4, 5... 로 순차적으로 실행될 것이다. 따라서 5번째 타이머는 앞선 4번의 대기 작업을 마치고 나서야 대기를 시작할 것이다. 응답성이 떨어지는 방식이다.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">random_timer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pending_time <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Wait </span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string"> for </span><span class="token interpolation"><span class="token punctuation">{</span>pending_time<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>pending_time<span class="token punctuation">)</span> <span class="token comment">#여기서 함수가 블락된다</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string"> is finished..."</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>random_timer<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">#create task?</span>
    <span class="token comment">#print(asyncio.all_tasks()) 테스크 현황 출력</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>


asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">await를 활용할 경우 이와 다른 방식으로 동작한다. <span class="red red-bg"><b>await를 만나는 순간 쓰레드는 해당 함수를 블락하고 상태를 저장 해둔 다음실행 가능한 다른 함수를 실행한다.</b></span> 따라서 다음의 순서로 동작한다.</p></div><div><p dir="auto">1번 실행 -&gt; 2번 실행 -&gt; 3,4,5번 실행  -&gt; 타이머가 먼저 종료되는 함수 부터 종료...</p></div><div><p dir="auto"><b><u>await를 활용할 경우 컨텍스트 스위칭 처럼 실행되는 프로세스의 교체가 진행되고 함수는 상태가 그대로 유지돼 await하고 있는 함수가 완료될 때까지 대기하다 다시 실행된다.</u></b> 따라서 일반적인 동기-블락킹보단 응답성이 개선된 방식으로 동작한다.</p></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><strong>await를 활용하면 해당 예약어를 선언한 시점에서 실행하는 함수를 교체한다.</strong> </p>
</div></div></div><div><p dir="auto"><strong>이를 이미지로 표현하면 아래와 같다. 여러 코루틴이 await를 기반으로 교체되며 병행적으로 실행된다.</strong></p></div><div><p dir="auto"><img src="https://my-study.s3.ap-northeast-2.amazonaws.com/Async%2CAwait%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-02-13%20%EC%98%A4%ED%9B%84%202.47.33.png" referrerpolicy="no-referrer"></p></div><div class="heading-wrapper"><h4 data-heading="create_task는 뭐야?" dir="auto" class="heading" id="create_task는_뭐야?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>create_task는 뭐야?</h4><div class="heading-children"><div><p dir="auto">create_task는 뭘까 아래와 같이 await를 즉각적으로 붙여서 코드를 작성할 수는 없을까?</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> random_timer<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">#위에 정의돼 있다</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">이렇게 코드를 작성하면 timer 함수가 끝날 때까지 main으로 실행 권한이 돌아오지 않기 때문에 이러한 코드를 작성하면 안된다.<br>
await는 크게 두가지의 기능을 수행하는데 첫번째는 예약어 뒤에 존재하는 <strong>코루틴을 실행하는 작업을 진행</strong>하고 두 번째로는 <strong>해당 코루틴이 완료될 때까지 실행권한을 이벤트 루프에 반환</strong>한다.</p></div><div><p dir="auto">이에 따라 <code class="code-styler-inline">await random_timer</code>를 실행하면 <code class="code-styler-inline">random_timer</code>를 실행하고 이후 <code class="code-styler-inline">await asyncio.sleep(pending_time)</code> 줄을 만나면 실행 권한을 다시 반환한다. 이때 main이 실행 권한을 얻어 코드가 이어 실행될듯 하지만 main은 <code class="code-styler-inline">await random_timer</code>가 종료될 때까지 블락 상태이기 때문에 실행 가능한 코루틴이 존재하지 않게 된다. 따라서 <strong>위와 같이 코드를 작성할 경우 타이머 함수를 병행적으로 실행하지 않고 한개씩 처리하는 동기-블락킹 방식으로 동작한다.</strong></p></div><div><p dir="auto">이를 해결하기 위해선 <span class="red red-bg">코루틴 여러 개를 이벤트 루프에 등록해주면 된다. 여러 개의 코루틴을 루프에 등록해줄 경우 하나의 코루틴이 권한을 반납하면 다른 코루틴을 실행해주면 된다. </span> 이를 <code class="code-styler-inline">create_task</code>가 가능케 해주며 각 코루틴을 task 객체로 감싸 이벤트 루프에 등록해 루프에게 처리할 작업이 복수개 존재한다는 것을 인지시킨다. </p></div><div><p dir="auto"><img src="https://my-study.s3.ap-northeast-2.amazonaws.com/Async%2CAwait%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-02-13%20%EC%98%A4%ED%9B%84%202.41.28.png" referrerpolicy="no-referrer"></p></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><strong>테스크 객체로 코루틴을 감싸줘야 루프가 작업을 스케줄링할 때 다룰 수 있다.</strong></p>
</div></div></div><div><hr dir="auto"></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Corutine" dir="auto" class="heading" id="Corutine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Corutine</h3><div class="heading-children"><div><p dir="auto">앞서 말했듯이 async/await는 상태를 저장하고 함수를 교체하는 작업을 수행한다. 이에 따라 <span class="red red-bg"><b>실행 흐름을 기억 했다 다시 실행하는 방식의 동작이 가능한 특별한 형태의 함수를 사용해야 하는데 이것이 코루틴이다.</b></span></p></div><div><p dir="auto"><strong>코루틴이 (await, yield)등을 통해 인위적으로 다른 곳으로 권한을 양도하면 자신의 실행과 관련된 상태를 어딘가에 저장하고 실행을 중지</strong>한다. 이후 다시금 코루틴을 실행하면 중지했던 부분에서 다시 상태를 복원해 작업을 진행한다. 코루틴은 제네레이터와 흡사하지만 <strong>제네레이터와 달리 초기화 이후 값을 전달받는 것이 가능하며 매개변수를 받을 수 있는 제네레이터로서 동작한다.</strong></p></div><div><p dir="auto">코루틴 객체를 만들기 위해서는 async 키워드를 서브 루틴 앞에 추가하면 된다. 이때 주의할 점은 <b><u>코루틴은 함수와 달리 호출을 해도 함수 내부의 코드가 동작하지 않고 코루틴 객체를 반환 한다는 것이다. </u></b> 함수 내부의 코드를 동작시켜 결과 값을 얻기 위해서는 await 구문을 활용해야 한다.</p></div><div><p dir="auto">또한 <strong>await 키워드는 코루틴 안에서만 호출할 수 있으므로 코루틴을 실행하기 위해서는 또 다른 코루틴이 요구 된다.</strong> 이 문제는 꼬리에 꼬리를 물며 계속 연결되므로 이를 해결하기 위해서는 코루틴의 시작을 일반 함수나 함수 외부에서 실행 할 수 있게 해줘야 한다.</p></div><div><p dir="auto"><code class="code-styler-inline">asyncio.run()</code>을 통해 이 문제를 해결할 수 있다. <code class="code-styler-inline">asyncio.run()</code>은 이벤트 루프를 생성하는 <code class="code-styler-inline">asyncio.get_loop()</code> 와 이벤트 루프를 실행하는 <code class="code-styler-inline">loop.run_until()</code> 을 합친 메서드이다. <code class="code-styler-inline">asyncio.run()</code> 이 실행되는 시점이 비동기 프로그램의 시작점(엔트리 포인트)이 되며 이를 통해 일반 함수에서 코루틴을 호출할 수 있다.</p></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="파이썬의 이벤트 루프" dir="auto" class="heading" id="파이썬의_이벤트_루프"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>파이썬의 이벤트 루프</h3><div class="heading-children"><div><p dir="auto">우리는 앞서 <a data-href="이벤트 루프" href="os/이벤트-루프.html" class="internal-link" target="_self" rel="noopener">이벤트 루프</a> 에서 이벤트 루프란 이벤트를 감지하고 이에 따른 적절한 처리를 수행하는 하나의 디자인 패턴이라는 것을 학습했다. 파이썬에서의 이벤트 루프도 크게 다르지 않다. 준비된 코루틴을 재개하고 대기가 필요한 코루틴들을 스케줄링하는 작업을 이벤트 루프가 담당한다.</p></div><div><p dir="auto"><strong>즉, 이벤트 루프는 무한 반복하며 코루틴을 하나 씩 실행 시키는 비동기 방식의 실행 주체</strong>이다.</p></div><div><p dir="auto"><span class="red red-bg"><b>실행 중인 코루틴에서 await하면 해당 코루틴은 이벤트 루프로 실행 권한을 양도한다.</b></span> 권한을 양도 받으면 이벤트 루프는 대기 상태인 태스크들을 순회하며 태스크의 상태를 구분하는 작업을 수행한다.<br>
이벤트 루프는 태스크의 상태를 준비, 대기로 구분하는데 준비 상태는 실행 준비가 완료된 태스크를 의미하고 대기 상태는 IO 작업이 계속 진행중인 태스크를 의미한다.</p></div><div><p dir="auto">대기 상태의 테스크는 대기 작업이 완료될 때 까지 상태가 보존 됐다가 대기가 끝나면 다시금 실행된다. 이를 위해선 <strong>테스크의 대기가 끝났다는 것을 확인하는 작업이 필요한데 이벤트 루프가 테스크를 반복적으로 호출하는 방식으로 이를 수행</strong>한다. 따라서 <strong>대기 작업이 끝났는지를 파악하고 스케줄링 하기 위해선 이벤트 루프에 작업을 등록해야만 한다.</strong></p></div><div><p dir="auto">테스크의 상태 구분이 완료되면 이벤트 루프는 준비 상태인 테스크 중 하나를 선택해 실행한다. 이후 위의 과정이 반복된다.</p></div><div><p dir="auto"><span class="red red-bg"><b>테스크는 인위적으로 명시한 부분에서만 권한을 이벤트 루프에 넘겨준다. 이 부분은 자동적으로 권한을 뺐는 멀티 스레딩과 차이가 존재한다.</b></span></p></div><div><p dir="auto">아래는 제네레이터를 활용해 구현한 이벤트 루프의 골조이다. 제네레이터에 매개변수를 전달하며 각 서브루틴을 교체로 실행하는 방식으로 동작하는 것을 확인할 수 있다. 이 아이디어를 발전 시킨 것이 async/await가 이다.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">def</span> <span class="token function">coroutine1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C1: Start'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token comment">#권한 반환</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C1: hello'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C1: end'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">coroutine2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C2: Start'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token comment">#권한 반환</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C2: hello'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C2: end'</span><span class="token punctuation">)</span>

<span class="token comment"># 이벤트 루프 실행</span>
<span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>cors<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> cors<span class="token punctuation">:</span>
        <span class="token keyword">for</span> co <span class="token keyword">in</span> <span class="token punctuation">[</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">]</span><span class="token punctuation">:</span>
            co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span> <span class="token comment">#제네레이터를 실행</span>

<span class="token comment"># 코루틴 객체 생성 =&gt; asyncio def</span>
c1 <span class="token operator">=</span> coroutine1<span class="token punctuation">(</span><span class="token punctuation">)</span>
c2 <span class="token operator">=</span> coroutine2<span class="token punctuation">(</span><span class="token punctuation">)</span>

task <span class="token operator">=</span> <span class="token punctuation">[</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">]</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FooHgS%2Fbtq8BDw8qQJ%2Ff2aNgf3naawkZGgcPC81QK%2Fimg.png" referrerpolicy="no-referrer"></p></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="Task" dir="auto" class="heading" id="Task"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Task</h3><div class="heading-children"><div><p dir="auto"><strong>Task 객체는 코루틴을 감싸는 객체로 코루틴이 비동기적으로 동작하기 위한 핸들러이다.</strong></p></div><div><p dir="auto"><mark><strong>코루틴들을 await로 실행하면 비동기적으로 작동하지 않고 동기적으로 작동한다.</strong></mark> 이는 await 구문이 단순히 코루틴을 실행하는 기능만을 가지고 있기 때문이다. 따라서 <strong>비동기적 사용을 위해선 스케줄링이 필요하고 이를 Task가 수행한다</strong>. <mark><strong>Task는 코루틴들을 비동기적으로 실행하기 위해 스케줄을 관리해주는 하나의 핸들러</strong></mark>라고 보면 된다.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> time
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">timer</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">}</span></span><span class="token string"> wait"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">}</span></span><span class="token string"> wait finish"</span></span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"start:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> timer<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> timer<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"end:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">위 코드는 이렇게 작동할 것 처럼 보여진다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>timer(1)→ wait → timer(2) → wait→ timer(1) end → timer(2) end</strong></li>
</ul></div><div><p dir="auto">하지만 실상 이렇게 동작한다.</p></div><div><ul dir="auto">
<li data-line="0" dir="auto"><strong>timer(1)→ wait → timer(1) end → timer(2) → wait → timer(2) end</strong></li>
</ul></div><div><p dir="auto">이러한 현상이 발생하는 이유는 앞서 말했듯이 <strong>이벤트 루프가 실행할 작업이 스케줄링 돼있지 않기 때문</strong>이다. 위 코드에서 이벤트 루프는 main()만을 스케줄링 한다. 따라서 main에서 await가 발생한다 하더라도 추후 실행할 작업이 존재하지 않기 때문에 무작정 대기하는 일이 발생한다.</p></div><div><p dir="auto">따라서 <strong>여러 코루틴을 비동기적으로 동작시키기 위해선 이벤트 루프가 코루틴들을 스케줄링 할 수 있어야 하고 이를 가능하게 코루틴을 감싸는 객체가 바로 Task</strong>이다.</p></div><div><p dir="auto"><strong>Task는 생성과 동시에 코루틴을 이벤트 루프에 등록(스케줄링) 시킨다.</strong> Task를 통해 특정 코루틴의 결과를 기다릴 수도 있고 코루틴을 중단하거나 실행 할 수도 있다. <strong>Task는 이벤트 루프에 등록된 코루틴을 컨트롤하는 핸들이다.</strong></p></div><div><blockquote dir="auto">
<p dir="auto"><mark><strong>It's an asyncio construct that tracks execution of a coroutine in a concrete event loop. When you call&nbsp;create_task, you submit a coroutine for execution and receive back a handle.</strong></mark> You can await this handle when you actually need the result, or you can never await it, if you don't care about the result. This handle is the&nbsp;task, and it inherits from&nbsp;Future, which makes it awaitable and also provides the lower-level callback-based interface, such as&nbsp;add_done_callback.</p>
</blockquote></div><div><p dir="auto">따라서 위의 코드를 이상적인 비동기-논블락킹으로 동작 시키고 싶다면 task 객체로 생성해 이벤트 루프에 등록해야 한다. 또한 이러한 과정은 <code class="code-styler-inline">create_task()</code>를 활용해 한번에 진행할 수 있다.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"start:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    futures <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>timer<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">#테스크를 반환</span>
    <span class="token keyword">for</span> f <span class="token keyword">in</span> futures<span class="token punctuation">:</span>
        <span class="token keyword">await</span> f <span class="token comment">#테스크의 완료까지 대기</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"end:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="Futures" dir="auto" class="heading" id="Futures"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Futures</h3><div class="heading-children"><div><p dir="auto">퓨처는 어떠한 작업의 실행 상태 및 결과를 저장하는 객체이다. 여기서 말하는 실행 상태는 <strong>작업이 대기 중인지 취소 됐는지 혹은 완료</strong> 됐는지를 의미한다. 작업의 대기는 PENDING 완료는 FINISHED와 CANCELED 2개로 구분된다. 퓨처에 저장되는 실행결과는 작업의 반환 값 혹은 예외이며 예외가 발생하더라도 상태는 FINISHED가 된다.</p></div><div><p dir="auto">퓨처는 JS의 promise와 흡사한 개념처럼 보이나 동일하진 않다 <strong>퓨처는 실행 상태와 결과를 저장만 할 뿐 실질적으로 실행을 개시하지는 않기</strong> 때문이다.</p></div><div><p dir="auto">퓨처의 주요 메서드로는 add_done_callback() 함수가 존재하며 이는 퓨처의 작업이 완료되면 바로 호출하는 콜백 함수를 등록하는 메서드이다. 등록된 콜백은 테스크가 완료되지마자 곧 바로 실행된다.</p></div><div><p dir="auto">파이썬에는 두개의 future가 존재하는데 <code class="code-styler-inline">concurrent.futures</code>와 <code class="code-styler-inline">asyncio.futures</code>이다. 두 futures는 호환되지 않으며 다른 목적을 갖는다. 전자의 futures가 우선 탄생됐으며 후자는 전자를 흉내 내고자 만들어졌다.</p></div><div class="heading-wrapper"><h4 data-heading="[concurrent.futures](https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future)" dir="auto" class="heading" id="[concurrent.futures](https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future" rel="noopener" class="external-link" href="https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future" target="_blank">concurrent.futures</a></h4><div class="heading-children"><div><p dir="auto"><strong>futures 모듈은 멀티 쓰레드 환경에서 각 쓰레드의 값들을 전달하고 넘겨받는 과정을 손쉽게 만들기 위해 탄생했다.</strong> 이전의 멀티 쓰레드 모듈은 전부 C를 기반으로 작성 됐기 때문에 전통적인 C와 동일하게 큐나 공유 변수 등을 통해 쓰레드간 통신을 진행 해야만 했다.</p></div><div><p dir="auto">퓨처 객체는 언젠가 어떠한 쓰레드에서 처리 됨을 보장받으며 사용자는 이에 콜백을 추가하거나 취소할 수 있다. 퓨처의 실행과 스케줄링은 사용자가 신경쓸 필요 없이 모두 Executor(실행자) 클래스에서 도맡아 진행한다. 따라서 사용자는 적절한 실행자를 선택해 해당 실행자에 진행하고 싶은 작업을 등록만 하면 된다.</p></div><div><p dir="auto">등록은 <code class="code-styler-inline">submit()</code>을 통해 진행할 수 있으며 결과 값으로 퓨처 객체가 반환 된다. 퓨처 객체는 이때 완료를 보장 하지는 않으므로 별도의 <code class="code-styler-inline">wait()</code>나 <code class="code-styler-inline">as_complted()</code> 또는 <code class="code-styler-inline">result()</code> 같은 함수로 퓨처의 작업이 완료될 때까지 대기해야 한다.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor <span class="token keyword">as</span> PE
<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> urlopen
<span class="token keyword">import</span> concurrent<span class="token punctuation">.</span>futures
URLS <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'http://www.foxnews.com'</span><span class="token punctuation">,</span>
    <span class="token string">'http://www.cnn.com'</span><span class="token punctuation">,</span>
    <span class="token string">'http://europe.wsj.com'</span><span class="token punctuation">,</span>
    <span class="token string">'http://www.bbc.co.uk'</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">load_url</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    conn <span class="token operator">=</span> urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> PE<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> exe<span class="token punctuation">:</span> <span class="token comment">#멀티 쓰레드 실행자</span>
        fs <span class="token operator">=</span> <span class="token punctuation">{</span>exe<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>load_url<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">:</span> url <span class="token keyword">for</span> url <span class="token keyword">in</span> URLS<span class="token punctuation">}</span> <span class="token comment">#퓨처 딕셔너리</span>
        <span class="token keyword">for</span> f <span class="token keyword">in</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>as_completed<span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                url <span class="token operator">=</span> fs<span class="token punctuation">[</span>f<span class="token punctuation">]</span>
                data <span class="token operator">=</span> f<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[</span><span class="token interpolation"><span class="token punctuation">{</span>url<span class="token punctuation">}</span></span><span class="token string">] has </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string"> characters.'</span></span><span class="token punctuation">)</span>
            <span class="token keyword">except</span> Exception<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Fail to open : </span><span class="token interpolation"><span class="token punctuation">{</span>url<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">위의 코드를 보면 멀티 쓰레드를 활용해 작업을 진행하고 각 쓰레드에서 실행된 작업의 결과를 하나의 쓰레드에서 손쉽게 획득하는 것을 확인할 수 있다. </p></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><strong>해당 퓨처스는 멀티 쓰레드 환경에서 비동기 처리를 위해 고안된 방식이다. 따라서 async/await와 연관이 없고 None-awaitable이다.</strong></p>
</div></div></div></div></div><div class="heading-wrapper"><h4 data-heading="단일 쓰레드 환경에서의 futures의 탄생" dir="auto" class="heading" id="단일_쓰레드_환경에서의_futures의_탄생"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>단일 쓰레드 환경에서의 futures의 탄생</h4><div class="heading-children"><div><blockquote dir="auto">
<p dir="auto"><code class="code-styler-inline">asyncio.Future</code>&nbsp;개념의 도입은 스레드를 관리하고, 다른 스레드에서 돌아가는 작업에 대해서 리턴을 동기화하는 등의 작업들이 매우 골치아팠던 것을 그 자체를 객체로 래핑하면서 매우 우아하게 처리할 수 있었다. 이를 통해 비선형적인 제어 흐름과 관계된 코드를 작성하는 것이 더 이상 너저분한 작업이 아닐 수 있게됐다.</p>
<p dir="auto"><strong>다중 스레드 및 다중 프로세스에 대해서&nbsp;<code class="code-styler-inline">Future</code>를 적용하는 것이 성공적이었다면, 이는 단일 스레드에 대해서도 비동기 non-blocking 코드를 작성하는데에 동일한&nbsp;<code class="code-styler-inline">Future</code>&nbsp;개념을 도입할 수 있지 않을까하는 것으로 아이디어가 옮겨갔다.</strong></p>
</blockquote></div><div><hr dir="auto"></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Corutine, Future, Task 한눈에 보기" dir="auto" class="heading" id="Corutine,_Future,_Task_한눈에_보기"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Corutine, Future, Task 한눈에 보기</h3><div class="heading-children"><div><p dir="auto"><mark><strong>asyncio 모듈에 한해서 위 3개의 객체는 전부 awaitable하므로 이벤트 루프에 권한을 양도하고 다른 작업을 처리하는 것이 가능하다.</strong></mark></p></div><div><p dir="auto"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdITHrN%2Fbtq8BmWfbIr%2FKKjtyW2gLmtEx5dE7pJkBk%2Fimg.png" referrerpolicy="no-referrer"></p></div><div><p dir="auto">중간에 나왔다가 들어갈 수 있는 서브 루틴의 구조를 코루틴이 구현한다. 실행중인 코루틴의 결과는 퓨처를 활용해 표현한다. 코루틴은 그 자체가 상태를 가질 수 없기 때문에 작업의 중단과 재개를 위해서 테스크를 활용한다.</p></div><div><p dir="auto"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fed6uEg%2Fbtrt1JocVB7%2FWbjhG6smnQ4PCu3zH2hou1%2Fimg.png" referrerpolicy="no-referrer"></p></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" dir="auto"><div class="callout-title" dir="auto"><div class="callout-icon" dir="auto"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner" dir="auto">Info</div></div><div class="callout-content" dir="auto">
<p dir="auto"><strong>테스크가 실행하는 작업이 코루틴이고 코루틴의 실행 상태는 퓨처로 나타내진다.</strong> </p>
</div></div></div><div><hr dir="auto"></div></div></div><div class="heading-wrapper"><h3 data-heading="파이썬 async의 실행 흐름 자세하게" dir="auto" class="heading" id="파이썬_async의_실행_흐름_자세하게"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>파이썬 async의 실행 흐름 자세하게</h3><div class="heading-children"><div><p dir="auto">이벤트 루프를 실행하면 전달 받은 코루틴을 통해 테스크 객체가 만들어지고, 이 과정에서 테스크의 실행이 이벤트 루프에 스케줄링 된다. 이때 <strong>실행이란 <code class="code-styler-inline">__step()</code>을 통해 테스크에 있는 코루틴을 실행하는 것</strong>을 말한다.</p></div><div><p dir="auto"><code class="code-styler-inline">__step()</code>이 실행되고 나면 해당 메서드는 테스크 객체의 <code class="code-styler-inline">__coro</code> 필드에 저장된 <code class="code-styler-inline">send()</code>를 실행해 코루틴을 실행하는 역할을 수행한다. 이제 이 코루틴을 시작점으로 await 키워드를 마주칠 때마다 새로운 코루틴을 실행하게 되면서 코루틴 체인이 구축된다.</p></div><div><p dir="auto">만약 <strong>코루틴의 반환 값이 퓨처일 경우 테스크는 퓨처 객체를 생성해 반환 값과 바인딩</strong>한다. 이후 바인딩한 퓨처 객체를 await하는데 <code class="code-styler-inline">__await__()</code>는 자기 자신을 반환하는 함수이므로 반환 값이 코루틴 체인을 타고 <code class="code-styler-inline">__step() </code> 까지 반환될 것이다.</p></div><div><p dir="auto"><mark>테스크 객체는 <code class="code-styler-inline">__step()</code>으로 yield된 퓨처 객체를 전달 받으면 이를 자신의 <code class="code-styler-inline">__fut_waiter</code> 필드에 바인딩한다.</mark> 이후 퓨처 객체가 완료 될 때 테스크를 재실행하기 위해 <code class="code-styler-inline">__step()</code> 함수를 이벤트 루프에 등록한다. 이 작업을 수행하고 나면 <mark>테스크는 자신의 작업은 중단하고 권한을 이벤트 루프로 양도한다.</mark></p></div><div><p dir="auto">이후 해당 테스크는 <code class="code-styler-inline">__fut_waiter</code> 필드에 값이 존재해 이벤트 루프의 실행 대상에서 제외되고 이벤트 루프는 다른 테스크를 실행한다.</p></div><div><p dir="auto">이후 이벤트 루프가 등록해뒀던 퓨처 작업의 완료를 확인하면  콜백으로 인해 <code class="code-styler-inline">__step()</code> 함수가 재실행된다.  함수는 테스크의 <code class="code-styler-inline">__fut_waiter</code>의 값을 비우고 <code class="code-styler-inline">send</code>를 활용해 코루틴을 다시 호출한다. 코루틴은 이전의 중단 부분 이었던 <code class="code-styler-inline">__await__()</code> 이후의 코드 부터 순차적으로 실행된다. </p></div><div><p dir="auto">아래 코드를 실행하면 실제로 변화하는 <code class="code-styler-inline">__fut_waiter</code>값을 확인할 수 있다.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"start:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>timer<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#등록한 코루틴을 실행하기 위해 권한 반납.</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>_fut_waiter<span class="token punctuation">)</span>
        <span class="token comment"># await t</span>

    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"end:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div class="heading-wrapper"><h4 data-heading="코루틴의 종료" dir="auto" class="heading" id="코루틴의_종료"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>코루틴의 종료</h4><div class="heading-children"><div><p dir="auto">이렇게 실행을 진행하다보면 언젠가 return을 통해 종료되는 코루틴을 만나게 된다. 코루틴이 종료되면 테스크의 <strong><code class="code-styler-inline">__step()</code>은 StopIteration을 만나게 되고 이로 인해 종료</strong>하게 된다. StopIteration이 반환되면 코루틴의 반환 값을 테스크의 result 필드에 저장한다. 이후 테스크는 더 이상 스케줄링 되지 않고 완전히 종료된다.</p></div><div><hr dir="auto"></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="await 주의점" dir="auto" class="heading" id="await_주의점"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>await 주의점</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="await가 항상 권한을 양도하진 않는다" dir="auto" class="heading" id="await가_항상_권한을_양도하진_않는다"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>await가 항상 권한을 양도하진 않는다</h4><div class="heading-children"><div><p dir="auto"><b><u>await를 실행할 경우 권한을 항상 이벤트 루프에 양도하진 않는다. 루프에 권한을 양도하는 경우는 코루틴의 실행 결과로 퓨처 객체가 반환되는 경우 만이다.</u></b> 아래의 예제를 보자.</p></div><div><pre dir="auto" class="language-python" tabindex="0"><code class="language-python is-loaded"><span class="token keyword">import</span> asyncio


<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">aprint</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>


<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">forever</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> aprint<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token comment"># await asyncio.sleep(0)</span>


<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>forever<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> forever<span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><code class="code-styler-inline">gather()</code>에 코루틴을 등록할 경우 자동으로 테스크 객체로 래핑이 되기 때문에 이벤트 루프에는 2개의 테스크가 존재하게 된다. 이에 따라 <code class="code-styler-inline">forever(a)</code>가 실행중 await를 만난다면 <code class="code-styler-inline">forever(b)</code>로 스위칭이 발생해야 하지만, 코드를 실행해보면 스위칭 없이 a만 계속해서 출력되는 것을 확인할 수 있다.</p></div><div><p dir="auto">이와 같은 현상이 발생하는 이유는 <strong>코루틴의 실행 결과가 퓨처 객체가 아니기 때문에 <code class="code-styler-inline">forever(a)</code> 가 실행 권한을 루프로 반환하지 않고 계속해서 사용하기 때문</strong>이다. 따라서 강제로 스위칭을 발생시키고 싶다면 해당 코루틴의 결과가 퓨처 객체로 반환될 수 있게 인위적으로 <code class="code-styler-inline">sleep</code>을 추가해주면 된다.</p></div></div></div><div class="heading-wrapper"><h4 data-heading="await coro != await task" dir="auto" class="heading" id="await_coro_!=_await_task"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>await coro != await task</h4><div class="heading-children"><div><p dir="auto">코루틴을 await하는 것과 task를 await하는 것은 다르다. 코루틴을 await하면 곧장 코루틴을 실행하는 반면 task를 await하면 이벤트 루프에 해당 테스크를 등록하고 이벤트 루프로 실행권한을 넘긴다. 따라서 코루틴을 곧장 await할 경우 바로 실행되지만, 태스크의 경우 곧장 실행되지 않을 수 있다.</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="os/async,await.html#Async,Await"><div class="tree-item-contents heading-link" heading-name="Async,Await"><span class="tree-item-title">Async,Await</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#출처"><div class="tree-item-contents heading-link" heading-name="출처"><span class="tree-item-title">출처</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#개요"><div class="tree-item-contents heading-link" heading-name="개요"><span class="tree-item-title">개요</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#Async_/_Await"><div class="tree-item-contents heading-link" heading-name="Async / Await"><span class="tree-item-title">Async / Await</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#Async/Await_의_동작방식"><div class="tree-item-contents heading-link" heading-name="Async/Await 의 동작방식"><span class="tree-item-title">Async/Await 의 동작방식</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/async,await.html#create_task는_뭐야?"><div class="tree-item-contents heading-link" heading-name="create_task는 뭐야?"><span class="tree-item-title">create_task는 뭐야?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#Corutine"><div class="tree-item-contents heading-link" heading-name="Corutine"><span class="tree-item-title">Corutine</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#파이썬의_이벤트_루프"><div class="tree-item-contents heading-link" heading-name="파이썬의 이벤트 루프"><span class="tree-item-title">파이썬의 이벤트 루프</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#Task"><div class="tree-item-contents heading-link" heading-name="Task"><span class="tree-item-title">Task</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#Futures"><div class="tree-item-contents heading-link" heading-name="Futures"><span class="tree-item-title">Futures</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/async,await.html#[concurrent.futures](https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future)"><div class="tree-item-contents heading-link" heading-name="[concurrent.futures](https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future)"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future" rel="noopener" class="external-link" href="https://docs.python.org/ko/3/library/concurrent.futures.html#concurrent.futures.Future" target="_blank">concurrent.futures</a></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/async,await.html#단일_쓰레드_환경에서의_futures의_탄생"><div class="tree-item-contents heading-link" heading-name="단일 쓰레드 환경에서의 futures의 탄생"><span class="tree-item-title">단일 쓰레드 환경에서의 futures의 탄생</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#Corutine,_Future,_Task_한눈에_보기"><div class="tree-item-contents heading-link" heading-name="Corutine, Future, Task 한눈에 보기"><span class="tree-item-title">Corutine, Future, Task 한눈에 보기</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#파이썬_async의_실행_흐름_자세하게"><div class="tree-item-contents heading-link" heading-name="파이썬 async의 실행 흐름 자세하게"><span class="tree-item-title">파이썬 async의 실행 흐름 자세하게</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/async,await.html#코루틴의_종료"><div class="tree-item-contents heading-link" heading-name="코루틴의 종료"><span class="tree-item-title">코루틴의 종료</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="os/async,await.html#await_주의점"><div class="tree-item-contents heading-link" heading-name="await 주의점"><span class="tree-item-title">await 주의점</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/async,await.html#await가_항상_권한을_양도하진_않는다"><div class="tree-item-contents heading-link" heading-name="await가 항상 권한을 양도하진 않는다"><span class="tree-item-title">await가 항상 권한을 양도하진 않는다</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="os/async,await.html#await_coro_!=_await_task"><div class="tree-item-contents heading-link" heading-name="await coro != await task"><span class="tree-item-title">await coro != await task</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>